const { time, loadFixture } = require("@nomicfoundation/hardhat-toolbox/network-helpers");
const { anyValue } = require("@nomicfoundation/hardhat-chai-matchers/withArgs");
const { expect } = require("chai");
const { assert } = require("console");

describe("Voting contract testing", function () {
  let voting;
  let owner, user1, user2, user3;

  // We define a fixture to reuse the same setup in every test.
  // We use loadFixture to run this setup once, snapshot that state,
  // and reset Hardhat Network to that snapshot in every test.
  async function deployVotingFixture() {
    // Contracts are deployed using the first signer/account by default
    const [owner, user1, user2, user3] = await ethers.getSigners();
    const Voting = await ethers.getContractFactory("Voting");
    voting = await Voting.deploy();
    return { voting, owner, user1, user2, user3 };
  }

  beforeEach(async () => {
    const fixture = await loadFixture(deployVotingFixture);
    voting = fixture.voting;
    owner = fixture.owner;
    user1 = fixture.user1;
    user2 = fixture.user2;
    user3 = fixture.user3;
  });

  describe("Voting contract deployment testing", function () {
    it("Should start with the right initial winningProposalID", async function () {
      let initialWinningProposalID = await voting.winningProposalID();
      expect(initialWinningProposalID.toString()).to.equal("0");
    })

    it("Should start with the right worflowStatus", async function () {
      let initialWorkflowStatus = await voting.workflowStatus();
      expect(initialWorkflowStatus.toString()).to.equal("0");
    });

    it("Should set the right owner", async function () {
      expect(await voting.owner()).to.equal(owner.address);
    });

    it("Should not set another owner", async function () {
      expect(await voting.owner()).to.not.equal(user1.address);
    });
  });

  describe("Getters testing", function () {
    describe("getVoter() function testing", function () {
      it("Should return added voters", async function () {
        await voting.addVoter(owner.address)
        await voting.addVoter(user1.address)
        let ownerRegistration = await voting.getVoter(owner.address)
        let voterRegistration = await voting.getVoter(user1.address)
        expect(ownerRegistration[0]).to.equal(true)
        expect(voterRegistration[0]).to.equal(true)
      })

      it("Should not return not-added voters", async function () {
        await voting.addVoter(owner.address)
        let ownerRegistration = await voting.getVoter(owner.address)
        let voterRegistration = await voting.getVoter(user2.address)
        expect(voterRegistration[0]).to.equal(false)
      })
      it("Should be reverted with \"You're not a voter\" if sender is not a registered voter", async function () {
        await expect(voting.getVoter(user2.address)).to.be.revertedWith("You're not a voter")
      })
    })

    describe("getOneProposal() function testing", function () {
      it("Should return added proposal with any registered user", async function () {
        const PROPOSAL_TEST_1 = "Ma proposition 01"
        const PROPOSAL_TEST_2 = "Ma proposition 02"
        await voting.addVoter(owner.address)
        await voting.addVoter(user1.address)
        await voting.startProposalsRegistering()
        await voting.addProposal(PROPOSAL_TEST_1)
        await voting.addProposal(PROPOSAL_TEST_2)
        let retrivedProposition = await voting.getOneProposal(1)
        let retrivedProposition2 = await voting.connect(user1).getOneProposal(2)
        expect(await retrivedProposition[0]).to.equal(PROPOSAL_TEST_1)
        expect(await retrivedProposition2[0]).to.equal(PROPOSAL_TEST_2)
      })
      it("Should revert when proposal doesn't exists", async function () {
        const PROPOSAL_TEST_1 = "Ma proposition 01"
        const PROPOSAL_TEST_2 = "Ma proposition 02"
        await voting.addVoter(owner.address)
        await voting.addVoter(user1.address)
        await voting.startProposalsRegistering()
        await voting.addProposal(PROPOSAL_TEST_1)
        await voting.addProposal(PROPOSAL_TEST_2)
        await expect(voting.getOneProposal(3)).to.be.reverted
      })

      it("Should revert when asked by unregistered user", async function () {
        const PROPOSAL_TEST_1 = "Ma proposition 01"
        const PROPOSAL_TEST_2 = "Ma proposition 02"
        await voting.addVoter(owner.address)
        await voting.startProposalsRegistering()
        await voting.addProposal(PROPOSAL_TEST_1)
        await voting.addProposal(PROPOSAL_TEST_2)
        await expect(voting.connect(user1).getOneProposal(2)).to.be.revertedWith("You're not a voter")

      })
    })
  })

  describe("OnlyOwner type functions testing", function () {
    describe("addVoter() function testing", function () {
      it("should revert when bad workflow status", async function () {
        await voting.startProposalsRegistering()
        await expect(voting.addVoter(owner.address)).to.be.revertedWith("Voters registration is not open yet")
        await voting.endProposalsRegistering()
        await expect(voting.addVoter(owner.address)).to.be.revertedWith("Voters registration is not open yet")
        await voting.startVotingSession()
        await expect(voting.addVoter(owner.address)).to.be.revertedWith("Voters registration is not open yet")
        await voting.endVotingSession()
        await expect(voting.addVoter(owner.address)).to.be.revertedWith("Voters registration is not open yet")
        await voting.tallyVotes()
        await expect(voting.addVoter(owner.address)).to.be.revertedWith("Voters registration is not open yet")
      })
      it("Should revert if voter already registered", async function () {
        await voting.addVoter(user1.address)
        await expect(voting.addVoter(user1.address)).to.be.revertedWith("Already registered")
      })
      it("Should revert if msg.sender is not owner", async function () {
        await expect(voting.connect(user1).addVoter(user1.address)).to.be.revertedWithCustomError(voting, "OwnableUnauthorizedAccount")
      })
      it("Should add the right voter", async function () {
        await voting.addVoter(owner.address)
        await voting.addVoter(user2.address)
        let retrievedVoter = await voting.getVoter(user2.address)
        expect(retrievedVoter[0]).to.equal(true)
      })
      it("Should not add the another voter", async function () {
        await voting.addVoter(owner.address)
        await voting.addVoter(user2.address)
        let retrievedVoter = await voting.getVoter(user1.address)
        expect(retrievedVoter[0]).to.equal(false)
      })
      it("Should emit the event VoterRegistered if successful", async function () {
        await expect(voting.addVoter(user2.address)).to.emit(voting, "VoterRegistered").withArgs(user2.address)
      })
    })

    describe("Workflow functions testing", function () {
      describe("startProposalsRegistering() function Testing", function () {
        it("Should revert if previous workflowStatus is not Registering Voters", async function () {
          await voting.startProposalsRegistering()
          await expect(voting.startProposalsRegistering()).to.be.revertedWith("Registering proposals cant be started now")
          await voting.endProposalsRegistering()
          await expect(voting.startProposalsRegistering()).to.be.revertedWith("Registering proposals cant be started now")
          await voting.startVotingSession()
          await expect(voting.startProposalsRegistering()).to.be.revertedWith("Registering proposals cant be started now")
          await voting.endVotingSession()
          await expect(voting.startProposalsRegistering()).to.be.revertedWith("Registering proposals cant be started now")
          await voting.tallyVotes()
          await expect(voting.startProposalsRegistering()).to.be.revertedWith("Registering proposals cant be started now")
        })
        it("Should change workflow status to ProposalsRegistrationStarted", async function () {
          await voting.startProposalsRegistering()
          expect((await voting.workflowStatus()).toString()).to.equal("1")
        })
        it("Should emit event WorkflowStatusChange from RegisteringVoters to ProposalsRegistrationStarted", async function () {
          await expect(voting.startProposalsRegistering()).to.emit(voting, "WorkflowStatusChange").withArgs("0", "1")
        })
        it("Should revert if msg.sender is not owner", async function () {
          await expect(voting.connect(user1).startProposalsRegistering()).to.be.revertedWithCustomError(voting, "OwnableUnauthorizedAccount")
        })
        it("Should set the first proposal description to GENESIS", async function () {
          await voting.addVoter(owner)
          await voting.startProposalsRegistering()
          expect((await voting.getOneProposal(0))[0]).to.equal("GENESIS")
        })
      })

      describe("endProposalsRegistering() function Testing", function () {
        it("Should revert if previous workflowStatus is not ProposalsRegistrationStarted", async function () {
          await expect(voting.endProposalsRegistering()).to.be.revertedWith("Registering proposals havent started yet")
          await voting.startProposalsRegistering()
          await voting.endProposalsRegistering()
          await expect(voting.endProposalsRegistering()).to.be.revertedWith("Registering proposals havent started yet")
          await voting.startVotingSession()
          await expect(voting.endProposalsRegistering()).to.be.revertedWith("Registering proposals havent started yet")
          await voting.endVotingSession()
          await expect(voting.endProposalsRegistering()).to.be.revertedWith("Registering proposals havent started yet")
          await voting.tallyVotes()
          await expect(voting.endProposalsRegistering()).to.be.revertedWith("Registering proposals havent started yet")
        })
        it("Should change workflow status to ProposalsRegistrationEnded", async function () {
          await voting.startProposalsRegistering()
          await voting.endProposalsRegistering()
          expect((await voting.workflowStatus()).toString()).to.equal("2")
        })
        it("Should emit event WorkflowStatusChange from ProposalsRegistrationStarted to ProposalsRegistrationEnded", async function () {
          await voting.startProposalsRegistering()
          await expect(voting.endProposalsRegistering()).to.emit(voting, "WorkflowStatusChange").withArgs("1", "2")
        })
        it("Should revert if msg.sender is not owner", async function () {
          await voting.startProposalsRegistering()
          await expect(voting.connect(user1).endProposalsRegistering()).to.be.revertedWithCustomError(voting, "OwnableUnauthorizedAccount")
        })
      })

      describe("startVotingSession() function Testing", function () {
        it("Should revert if previous workflowStatus is not ProposalsRegistrationEnded ", async function () {
          await expect(voting.startVotingSession()).to.be.revertedWith("Registering proposals phase is not finished")
          await voting.startProposalsRegistering()
          await expect(voting.startVotingSession()).to.be.revertedWith("Registering proposals phase is not finished")
          await voting.endProposalsRegistering()
          await voting.startVotingSession()
          await expect(voting.startVotingSession()).to.be.revertedWith("Registering proposals phase is not finished")
          await voting.endVotingSession()
          await expect(voting.startVotingSession()).to.be.revertedWith("Registering proposals phase is not finished")
          await voting.tallyVotes()
          await expect(voting.startVotingSession()).to.be.revertedWith("Registering proposals phase is not finished")
        })
        it("Should change workflow status to VotingSessionStarted", async function () {
          await voting.startProposalsRegistering()
          await voting.endProposalsRegistering()
          await voting.startVotingSession()
          expect((await voting.workflowStatus()).toString()).to.equal("3")
        })
        it("Should emit event WorkflowStatusChange from ProposalsRegistrationEnded to VotingSessionStarted", async function () {
          await voting.startProposalsRegistering()
          await voting.endProposalsRegistering()
          await expect(voting.startVotingSession()).to.emit(voting, "WorkflowStatusChange").withArgs("2", "3")
        })
        it("Should revert if msg.sender is not owner", async function () {
          await voting.startProposalsRegistering()
          await voting.endProposalsRegistering()
          await expect(voting.connect(user1).startVotingSession()).to.be.revertedWithCustomError(voting, "OwnableUnauthorizedAccount")
        })
      })

      describe("endVotingSession() function Testing", function () {
        it("Should revert if previous workflowStatus is not VotingSessionStarted", async function () {
          await expect(voting.endVotingSession()).to.be.revertedWith("Voting session havent started yet")
          await voting.startProposalsRegistering()
          await expect(voting.endVotingSession()).to.be.revertedWith("Voting session havent started yet")
          await voting.endProposalsRegistering()
          await expect(voting.endVotingSession()).to.be.revertedWith("Voting session havent started yet")
          await voting.startVotingSession()
          await voting.endVotingSession()
          await expect(voting.endVotingSession()).to.be.revertedWith("Voting session havent started yet")
          await voting.tallyVotes()
          await expect(voting.endVotingSession()).to.be.revertedWith("Voting session havent started yet")
        })
        it("Should change workflow status to VotingSessionEnded", async function () {
          await voting.startProposalsRegistering()
          await voting.endProposalsRegistering()
          await voting.startVotingSession()
          await voting.endVotingSession()
          expect((await voting.workflowStatus()).toString()).to.equal("4")
        })
        it("Should emit event WorkflowStatusChange from VotingSessionStarted to VotingSessionEnded", async function () {
          await voting.startProposalsRegistering()
          await voting.endProposalsRegistering()
          await voting.startVotingSession()
          await expect(voting.endVotingSession()).to.emit(voting, "WorkflowStatusChange").withArgs("3", "4")
        })
        it("Should revert if msg.sender is not owner", async function () {
          await voting.startProposalsRegistering()
          await voting.endProposalsRegistering()
          await voting.startVotingSession()
          await expect(voting.connect(user1).endVotingSession()).to.be.revertedWithCustomError(voting, "OwnableUnauthorizedAccount")
        })
      })

      describe("tallyVotes() function Testing", function () {
        it("Should revert if previous workflowStatus is not VotingSessionEnded", async function () {
          await expect(voting.tallyVotes()).to.be.revertedWith("Current status is not voting session ended")
          await voting.startProposalsRegistering()
          await expect(voting.tallyVotes()).to.be.revertedWith("Current status is not voting session ended")
          await voting.endProposalsRegistering()
          await expect(voting.tallyVotes()).to.be.revertedWith("Current status is not voting session ended")
          await voting.startVotingSession()
          await expect(voting.tallyVotes()).to.be.revertedWith("Current status is not voting session ended")
          await voting.endVotingSession()
          await voting.tallyVotes()
          await expect(voting.tallyVotes()).to.be.revertedWith("Current status is not voting session ended")
        })
        it("Should change workflow status to VotesTallied", async function () {
          await voting.startProposalsRegistering()
          await voting.endProposalsRegistering()
          await voting.startVotingSession()
          await voting.endVotingSession()
          await voting.tallyVotes()
          expect((await voting.workflowStatus()).toString()).to.equal("5")
        })
        it("Should emit event WorkflowStatusChange from VotingSessionEnded to VotesTallied", async function () {
          await voting.startProposalsRegistering()
          await voting.endProposalsRegistering()
          await voting.startVotingSession()
          await voting.endVotingSession()
          await expect(voting.tallyVotes()).to.emit(voting, "WorkflowStatusChange").withArgs("4", "5")
        })
        it("Should revert if msg.sender is not owner", async function () {
          await voting.startProposalsRegistering()
          await voting.endProposalsRegistering()
          await voting.startVotingSession()
          await voting.endVotingSession()
          await expect(voting.connect(user1).tallyVotes()).to.be.revertedWithCustomError(voting, "OwnableUnauthorizedAccount")
        })
        it("Should set the winningProposalId to the winning proposal", async function () {
          await voting.addVoter(owner)
          await voting.addVoter(user1)
          await voting.addVoter(user2)
          await voting.addVoter(user3)
          await voting.startProposalsRegistering()
          await voting.addProposal("Ma proposition 01")
          await voting.addProposal("Ma proposition 02")
          await voting.connect(user2).addProposal("Ma proposition 03")
          await voting.endProposalsRegistering()
          await voting.startVotingSession()
          await voting.setVote(1)
          await voting.connect(user1).setVote(3)
          await voting.connect(user2).setVote(2)
          await voting.connect(user3).setVote(3)
          await voting.endVotingSession()
          voting.tallyVotes()
          ppal = await voting.winningProposalID()
          expect(Number((await voting.winningProposalID()))).to.equal(3)
        })
      })
    })
  })

  describe("Setters functions testing", function () {
    describe("addProposal() function testing", function () {
      it("Should revert if previous workflowStatus is not ProposalsRegistrationStarted", async function () {
        await voting.addVoter(owner)
        await expect(voting.addProposal("Ma proposition")).to.be.revertedWith("Proposals are not allowed yet")
        await voting.startProposalsRegistering()
        await voting.endProposalsRegistering()
        await expect(voting.addProposal("Ma proposition")).to.be.revertedWith("Proposals are not allowed yet")
        await voting.startVotingSession()
        await expect(voting.addProposal("Ma proposition")).to.be.revertedWith("Proposals are not allowed yet")
        await voting.endVotingSession()
        await expect(voting.addProposal("Ma proposition")).to.be.revertedWith("Proposals are not allowed yet")
        await voting.tallyVotes()
        await expect(voting.addProposal("Ma proposition")).to.be.revertedWith("Proposals are not allowed yet")
      })
      it("Should revert if msg.sender not a registered Voter", async function () {
        await voting.addVoter(owner)
        await voting.startProposalsRegistering()
        await expect(voting.connect(user1).addProposal("Ma proposition")).to.be.revertedWith("You're not a voter")
      })
      it("Should revert if proposal description is empty", async function () {
        await voting.addVoter(owner)
        await voting.startProposalsRegistering()
        await expect(voting.addProposal("")).to.be.revertedWith("Vous ne pouvez pas ne rien proposer")
      })
      it("Should add a proposal", async function () {
        const PROPOSAL_TEST_1 = "Ma proposition 01"
        await voting.addVoter(owner.address)
        await voting.startProposalsRegistering()
        await voting.addProposal(PROPOSAL_TEST_1)
        let retrivedProposition = await voting.getOneProposal(1)
        expect(await retrivedProposition[0]).to.equal(PROPOSAL_TEST_1)
      })
    })

    describe("setVote() function testing", function () {
      it("Should revert if msg.sender not a registered Voter", async function () {
        await voting.addVoter(user1)
        await voting.startProposalsRegistering()
        await voting.connect(user1).addProposal("Ma proposition 01")
        await voting.connect(user1).addProposal("Ma proposition 02")
        await voting.endProposalsRegistering()
        await voting.startVotingSession()
        await expect(voting.setVote(1)).to.be.revertedWith("You're not a voter")
      })
      it("Should revert if workFlowstatus is not VotingSessionStarted", async function () {
        await voting.addVoter(owner)
        await voting.addVoter(user1)
        await expect(voting.setVote(1)).to.be.revertedWith("Voting session havent started yet")
        await voting.startProposalsRegistering()
        await expect(voting.setVote(1)).to.be.revertedWith("Voting session havent started yet")
        await voting.connect(user1).addProposal("Ma proposition 01")
        await voting.connect(user1).addProposal("Ma proposition 02")
        await voting.endProposalsRegistering()
        await expect(voting.setVote(1)).to.be.revertedWith("Voting session havent started yet")
        await voting.startVotingSession()
        await voting.endVotingSession()
        await expect(voting.setVote(1)).to.be.revertedWith("Voting session havent started yet")
        await voting.tallyVotes()
        await expect(voting.setVote(1)).to.be.revertedWith("Voting session havent started yet")
      })
      it("Should revert if msg.sender has already voted", async function () {
        await voting.addVoter(owner)
        await voting.startProposalsRegistering()
        await voting.addProposal("Ma proposition 01")
        await voting.addProposal("Ma proposition 02")
        await voting.endProposalsRegistering()
        await voting.startVotingSession()
        await voting.setVote(1)
        await expect(voting.setVote(1)).to.be.revertedWith("You have already voted")
      })
      it("Should revert if proposal doesn't exists", async function () {
        await voting.addVoter(owner)
        await voting.startProposalsRegistering()
        await voting.addProposal("Ma proposition 01")
        await voting.addProposal("Ma proposition 02")
        await voting.endProposalsRegistering()
        await voting.startVotingSession()
        await expect(voting.setVote(3)).to.be.revertedWith("Proposal not found")
      })
      it("Should store the Voter's votedProposalId", async function () {
        await voting.addVoter(owner)
        await voting.addVoter(user1)
        await voting.startProposalsRegistering()
        await voting.addProposal("Ma proposition 01")
        await voting.addProposal("Ma proposition 02")
        await voting.endProposalsRegistering()
        await voting.startVotingSession()
        await voting.setVote(1)
        expect((await voting.connect(user1).getVoter(owner.address))[2].toString()).to.equal("1")
      })
      it("Should increment the votedProposal vote count", async function () {
        await voting.addVoter(owner)
        await voting.addVoter(user1)
        await voting.startProposalsRegistering()
        await voting.addProposal("Ma proposition 01")
        await voting.addProposal("Ma proposition 02")
        await voting.endProposalsRegistering()
        await voting.startVotingSession()
        previousVoteCountofProposal1 = (await voting.getOneProposal(1))[1]
        await voting.setVote(1)
        expect(Number((await voting.getOneProposal(1))[1])).to.equal((Number(previousVoteCountofProposal1)+1))
      })
      it("Should emit event Voted(msg.sender, voted_id)", async function () {
        await voting.addVoter(owner)
        await voting.addVoter(user1)
        await voting.startProposalsRegistering()
        await voting.addProposal("Ma proposition 01")
        await voting.addProposal("Ma proposition 02")
        await voting.endProposalsRegistering()
        await voting.startVotingSession()
        await expect(voting.setVote(1)).to.emit(voting,"Voted").withArgs(owner.address,1)
      })
    })

  })

});
